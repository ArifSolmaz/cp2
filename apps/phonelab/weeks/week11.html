<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Week 11 â€” PhoneLab</title>
  <link rel="stylesheet" href="../assets/styles.css" />
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="brand-title">Week 11 â€” Game Character Builder</div>
      <div class="brand-sub"><a href="../index.html">â† Back to PhoneLab Hub</a></div>
    </div>
  </header>

  <main class="container">
    <section class="card">
      <h1 style="margin:0 0 4px;">ğŸ® Game Character Builder</h1>
      <p class="muted" style="margin:0 0 12px;">
        An RPG class system <em>is</em> a Python class system!
        Build <b>Character</b> â†’ <b>Warrior / Mage / Archer</b> with
        inheritance, abstract methods, mixins, and polymorphic combat.
      </p>

      <div class="concepts-box">
        <b>ğŸ“š Concepts you'll practice (from Week 11):</b>
        <span class="concept-tag">inheritance / subclass</span>
        <span class="concept-tag">super()</span>
        <span class="concept-tag">method overriding</span>
        <span class="concept-tag">polymorphism</span>
        <span class="concept-tag">ABC / @abstractmethod</span>
        <span class="concept-tag">multiple inheritance / mixin</span>
        <span class="concept-tag">isinstance() / MRO</span>
      </div>

      <!-- Step indicator -->
      <div class="steps" style="margin-top:14px;">
        <div class="step-pill active" data-step="1">â‘  Identity</div>
        <div class="step-pill" data-step="2">â‘¡ Data</div>
        <div class="step-pill" data-step="3">â‘¢ Code</div>
        <div class="step-pill" data-step="4">â‘£ Run & Submit</div>
      </div>

      <details open id="sec1">
        <summary><b>1) Identity</b> <span class="muted">(required)</span></summary>
        <div class="row">
          <div>
            <label>Student ID (6â€“12 digits)</label>
            <input id="studentId" inputmode="numeric" minlength="6" maxlength="12"
                   pattern="^\d{6,12}$" required placeholder="e.g., 202612345" />
          </div>
          <div>
            <label>Name Surname</label>
            <input id="nameSurname" required placeholder="e.g., Arif Solmaz" />
          </div>
        </div>
        <label>Email (@istun.edu.tr)</label>
        <input id="email" type="email"
               pattern="^[A-Za-z0-9._%+-]+@istun\.edu\.tr$"
               required placeholder="name@istun.edu.tr" />
        <small class="hint">Draft auto-saves on this device.</small>
      </details>

      <hr />

      <details open id="sec2">
        <summary><b>2) Collect your data</b> <span class="muted">(from your favorite games)</span></summary>

        <div class="scenario-box">
          <b>ğŸ”¬ What to do:</b>
          <ol class="muted" style="margin:6px 0 0; padding-left:20px;">
            <li>Think of <b>6 characters</b> from games you play or know
              (Zelda, Elden Ring, Genshin Impact, LoL, Valorant, Minecraft, etc.).</li>
            <li>For each character, record:
              <ul style="margin-top:4px;">
                <li><b>Name</b> (e.g., Link, Gandalf, Legolas)</li>
                <li><b>Class:</b> warrior, mage, archer, or paladin</li>
                <li><b>HP</b> (hit points, 50â€“500)</li>
                <li><b>Attack power</b> (10â€“100)</li>
              </ul>
            </li>
            <li>Include at least: <b>1 warrior</b>, <b>1 mage</b>, <b>1 archer</b>, and <b>1 paladin</b>.</li>
            <li>Format: <code>Name,class,hp,attack</code></li>
          </ol>
          <small>ğŸ’¡ <b>Tip:</b> You can also invent your own characters! The paladin class will demonstrate <b>multiple inheritance</b> (Warrior + HealMixin).</small>
        </div>

        <label>Your 6 characters (one per line)</label>
        <textarea id="dataBox" spellcheck="false"></textarea>
        <small class="hint">âš ï¸ Enter <b>your own</b> characters. Default values will be rejected.</small>
      </details>

      <hr />

      <details id="sec3">
        <summary><b>3) Python code</b> <span class="muted">(inheritance hierarchy)</span></summary>
        <label>Python â€” build the RPG class system</label>
        <textarea id="codeBox" class="codebox" spellcheck="false"></textarea>
        <small class="hint">
          Build <b>ABC</b>, <b>subclasses</b>, <b>override methods</b>,
          <b>super()</b>, <b>mixin</b>, <b>multiple inheritance</b>,
          and <b>polymorphic</b> functions.
        </small>
      </details>

      <hr />

      <details id="sec4">
        <summary><b>4) Output</b> <span class="muted">(auto-captured after Run)</span></summary>
        <pre id="output" class="out">Click "â–¶ Run Python" to see output here.</pre>
      </details>

      <div class="stickybar">
        <div class="bar-actions">
          <button id="helpBtn" class="helpbtn" type="button">?</button>
          <button id="runBtn" type="button">â–¶ Run Python</button>
          <button id="submitBtn" class="primary" type="button">Submit âœ“</button>
        </div>
        <small id="status" class="hint"></small>
      </div>
    </section>
  </main>

  <!-- Help Modal -->
  <div id="helpModal" class="modal-backdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h3>ğŸ® Week 11 â€” Instructions</h3>
      <ol class="muted">
        <li><b>Identity:</b> Student ID (6â€“12 digits), Name Surname, <b>@istun.edu.tr</b> email.</li>
        <li><b>Pick characters:</b> Choose 6 game characters â€” real or invented. Include at least 1 warrior, 1 mage, 1 archer, 1 paladin.</li>
        <li><b>Enter data:</b> One per line: <code>Name,class,hp,attack</code></li>
        <li><b>Write code:</b> Complete the TODOs â€” build the full inheritance hierarchy.</li>
        <li><b>Run:</b> Tap "â–¶ Run Python" and watch the RPG system come alive.</li>
        <li><b>Submit:</b> One submission only.</li>
      </ol>
      <p class="muted" style="margin-top:10px;">
        <b>ğŸ“ The engineering:</b> In mechatronics, inheritance models real hierarchies â€”
        <code>Actuator</code> â†’ <code>Motor</code> / <code>Servo</code> / <code>Stepper</code>,
        each overriding <code>move()</code> differently. Abstract base classes define
        sensor interfaces that every driver must implement. The Paladin = Warrior + HealMixin
        pattern mirrors <code>SmartSensor(Sensor, NetworkMixin)</code> in IoT systems!
      </p>
      <div class="modal-actions">
        <button id="closeHelpBtn" type="button">Got it</button>
      </div>
    </div>
  </div>

  <script src="../assets/app.js"></script>
  <script>
    const WEEK = "week11";
    const DEADLINE = new Date("2026-04-29T23:59:00+03:00");

    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxu_JAL7pMXz_7bSGC7kIYvs76UGJji8ubbmr6h7rnLY-M2deKSubTxTiekeKecMclC/exec";

    const studentIdEl   = document.getElementById("studentId");
    const nameSurnameEl = document.getElementById("nameSurname");
    const emailEl       = document.getElementById("email");
    const dataEl        = document.getElementById("dataBox");
    const codeEl        = document.getElementById("codeBox");
    const outEl         = document.getElementById("output");
    const statusEl      = document.getElementById("status");

    // â”€â”€ Default data â”€â”€
    const defaultData =
`Arthas,warrior,350,75
Gandalf,mage,200,90
Legolas,archer,220,80
Uther,paladin,300,60
Jaina,mage,180,95
Sylvanas,archer,210,85`;

    const starterCode =
`# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Week 11 â€” Game Character Builder
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from abc import ABC, abstractmethod

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 1: Define ABSTRACT BASE CLASS â€” Character
#         Use ABC and @abstractmethod
#         Abstract methods: attack(), defend()
#         Concrete: __init__, __str__, take_damage()
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Character(ABC):
    """Abstract base class for all game characters."""

    character_count = 0   # class attribute

    def __init__(self, name, hp, attack_power):
        self.name = name
        self.max_hp = int(hp)
        self.hp = int(hp)
        self.attack_power = int(attack_power)
        Character.character_count += 1

    def __str__(self):
        return f"{self.name} [{self.__class__.__name__}] HP:{self.hp}/{self.max_hp} ATK:{self.attack_power}"

    def take_damage(self, amount):
        """Reduce HP (concrete method â€” shared by all)."""
        self.hp = max(0, self.hp - amount)
        return self.hp > 0   # True if still alive

    @abstractmethod
    def attack(self):
        """Each subclass must define its own attack style."""
        pass

    @abstractmethod
    def defend(self):
        """Each subclass must define its own defense style."""
        pass

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 2: Define WARRIOR subclass
#         Inherits from Character
#         Override attack() â†’ "âš”ï¸ Slash" (full power)
#         Override defend() â†’ "ğŸ›¡ï¸ Shield Block" (reduce 50%)
#         Use super().__init__() to call parent constructor
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Warrior(Character):
    """Melee fighter â€” high HP, strong defense."""

    def __init__(self, name, hp, attack_power):
        super().__init__(name, hp, attack_power)
        self.armor = 0.5   # 50% damage reduction

    def attack(self):
        damage = self.attack_power
        return damage, f"âš”ï¸ {self.name} slashes for {damage} damage!"

    def defend(self):
        block = int(self.attack_power * self.armor)
        return block, f"ğŸ›¡ï¸ {self.name} raises shield, blocking {block} damage!"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 3: Define MAGE subclass
#         Override attack() â†’ "ğŸ”¥ Fireball" (1.5x power)
#         Override defend() â†’ "âœ¨ Magic Barrier" (reduce 30%)
#         Add mana attribute in __init__ using super()
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Mage(Character):
    """Magic caster â€” high attack, lower HP."""

    def __init__(self, name, hp, attack_power):
        super().__init__(name, hp, attack_power)
        self.mana = 100

    def attack(self):
        damage = int(self.attack_power * 1.5)
        self.mana = max(0, self.mana - 15)
        return damage, f"ğŸ”¥ {self.name} casts Fireball for {damage} damage! (Mana: {self.mana})"

    def defend(self):
        barrier = int(self.attack_power * 0.3)
        return barrier, f"âœ¨ {self.name} conjures Magic Barrier, absorbing {barrier} damage!"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 4: Define ARCHER subclass
#         Override attack() â†’ "ğŸ¹ Arrow" (1.2x power)
#         Override defend() â†’ "ğŸ’¨ Dodge" (evade chance)
#         Override __str__ to add arrows count
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Archer(Character):
    """Ranged fighter â€” balanced stats, high precision."""

    def __init__(self, name, hp, attack_power):
        super().__init__(name, hp, attack_power)
        self.arrows = 20

    def attack(self):
        damage = int(self.attack_power * 1.2)
        self.arrows = max(0, self.arrows - 1)
        return damage, f"ğŸ¹ {self.name} fires arrow for {damage} damage! (Arrows: {self.arrows})"

    def defend(self):
        dodge = int(self.attack_power * 0.4)
        return dodge, f"ğŸ’¨ {self.name} dodges, avoiding {dodge} damage!"

    def __str__(self):
        """Override parent __str__ to add arrow count."""
        base = super().__str__()
        return f"{base} ğŸ¹:{self.arrows}"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 5: Define HEALMIXIN â€” a mixin class
#         Adds heal() method to any class
#         Not a standalone class â€” designed to be mixed in
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HealMixin:
    """Mixin that adds healing ability to any character."""

    heal_amount = 30   # class attribute

    def heal(self):
        """Restore HP up to max."""
        before = self.hp
        self.hp = min(self.max_hp, self.hp + HealMixin.heal_amount)
        healed = self.hp - before
        return healed, f"ğŸ’š {self.name} heals for {healed} HP! (HP: {self.hp}/{self.max_hp})"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 6: Define PALADIN â€” MULTIPLE INHERITANCE
#         Inherits from BOTH Warrior AND HealMixin
#         Override attack() to call super() version + add holy
#         Demonstrate MRO
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class Paladin(Warrior, HealMixin):
    """Holy warrior â€” can fight AND heal (multiple inheritance)."""

    def __init__(self, name, hp, attack_power):
        super().__init__(name, hp, attack_power)
        self.faith = 100

    def attack(self):
        """Override Warrior's attack â€” add holy damage."""
        base_dmg, base_msg = super().attack()   # calls Warrior.attack()
        holy_bonus = 15
        total = base_dmg + holy_bonus
        return total, f"âœï¸ {self.name} performs Holy Strike for {total} damage! (+{holy_bonus} holy)"

    def defend(self):
        """Use Warrior's shield block."""
        return super().defend()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 7: Define POLYMORPHIC functions
#         battle(c1, c2) â€” works with ANY Character subclass
#         show_party(list) â€” prints any mix of characters
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def battle_round(attacker, defender):
    """Polymorphic battle â€” works with any Character subclass."""
    dmg, atk_msg = attacker.attack()
    block, def_msg = defender.defend()
    net_damage = max(0, dmg - block)
    alive = defender.take_damage(net_damage)
    return dmg, block, net_damage, atk_msg, def_msg, alive

def show_party(characters):
    """Polymorphic display â€” works with any list of Characters."""
    for c in characters:
        print(f"  {c}")    # calls each class's own __str__

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TODO 8: Use isinstance() and type checking
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def classify_character(char):
    """Use isinstance to classify characters."""
    roles = []
    if isinstance(char, Warrior):
        roles.append("Frontline")
    if isinstance(char, Mage):
        roles.append("Spellcaster")
    if isinstance(char, Archer):
        roles.append("Ranged")
    if isinstance(char, HealMixin):
        roles.append("Healer")
    if isinstance(char, Character):
        roles.append("Character")
    return roles


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN PROGRAM â€” build and battle!
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

_lines = DATA.strip().split("\\n")

CLASS_MAP = {
    "warrior": Warrior,
    "mage": Mage,
    "archer": Archer,
    "paladin": Paladin,
}

print("=" * 55)
print("ğŸ® GAME CHARACTER BUILDER")
print("=" * 55)

# â”€â”€ Create characters using factory pattern â”€â”€

print("\\nCREATING PARTY:")
party = []
for line in _lines:
    parts = [p.strip() for p in line.split(",")]
    name, cls_name, hp, atk = parts[0], parts[1].lower(), parts[2], parts[3]
    CharClass = CLASS_MAP.get(cls_name, Warrior)
    char = CharClass(name, hp, atk)
    party.append(char)
    print(f"  + {char}")

print(f"\\n  Character.character_count = {Character.character_count}")

# â”€â”€ Demonstrate isinstance() â”€â”€

print(f"\\n{'â”€' * 55}")
print("TYPE CLASSIFICATION (isinstance):")
for char in party:
    roles = classify_character(char)
    print(f"  {char.name:12s} â†’ {roles}")

# â”€â”€ Demonstrate issubclass() â”€â”€

print(f"\\n  issubclass(Paladin, Warrior) = {issubclass(Paladin, Warrior)}")
print(f"  issubclass(Paladin, HealMixin) = {issubclass(Paladin, HealMixin)}")
print(f"  issubclass(Mage, Character) = {issubclass(Mage, Character)}")

# â”€â”€ Show MRO for Paladin â”€â”€

print(f"\\n{'â”€' * 55}")
print("METHOD RESOLUTION ORDER (MRO):")
print(f"  Paladin MRO: {[c.__name__ for c in Paladin.__mro__]}")
print(f"  Warrior MRO: {[c.__name__ for c in Warrior.__mro__]}")

# â”€â”€ ABC demo: try to instantiate abstract class â”€â”€

print(f"\\n{'â”€' * 55}")
print("ABSTRACT BASE CLASS TEST:")
try:
    ghost = Character("Ghost", 100, 50)
except TypeError as e:
    print(f"  âœ… Cannot instantiate ABC: {type(e).__name__}")

# â”€â”€ Polymorphic battle â”€â”€

print(f"\\n{'â”€' * 55}")
print("âš”ï¸ POLYMORPHIC BATTLE:")

# Pick first two different-class characters
fighters = party[:2] if len(party) >= 2 else party
if len(fighters) >= 2:
    c1, c2 = fighters[0], fighters[1]
    print(f"\\n  {c1.name} vs {c2.name}!")
    print()

    for round_num in range(1, 4):
        print(f"  â”€â”€ Round {round_num} â”€â”€")
        dmg, block, net, atk_msg, def_msg, alive = battle_round(c1, c2)
        print(f"    {atk_msg}")
        print(f"    {def_msg}")
        print(f"    Net damage: {net} â†’ {c2.name} HP: {c2.hp}/{c2.max_hp}")
        if not alive:
            print(f"    ğŸ’€ {c2.name} has fallen!")
            break
        print()

# â”€â”€ Paladin healing demo â”€â”€

print(f"\\n{'â”€' * 55}")
print("ğŸ’š PALADIN HEALING (from HealMixin):")

paladins = [c for c in party if isinstance(c, Paladin)]
if paladins:
    pal = paladins[0]
    # Simulate some damage first
    pal.take_damage(50)
    print(f"  {pal.name} took 50 damage â†’ HP: {pal.hp}/{pal.max_hp}")
    healed, msg = pal.heal()
    print(f"  {msg}")
else:
    print("  (No paladin in party â€” add one with class 'paladin')")

# â”€â”€ Polymorphic party display â”€â”€

print(f"\\n{'â”€' * 55}")
print("FULL PARTY (polymorphic __str__):")
show_party(party)

# â”€â”€ Method overriding comparison â”€â”€

print(f"\\n{'â”€' * 55}")
print("ATTACK STYLES (method overriding):")
for char in party:
    _, msg = char.attack()
    print(f"  {msg}")

# â”€â”€ Final stats â”€â”€

print(f"\\n{'=' * 55}")

warriors = [c for c in party if isinstance(c, Warrior)]
mages = [c for c in party if isinstance(c, Mage)]
archers = [c for c in party if isinstance(c, Archer)]
healers = [c for c in party if isinstance(c, HealMixin)]

total_hp = sum(c.max_hp for c in party)
total_atk = sum(c.attack_power for c in party)
avg_hp = total_hp / len(party) if party else 0

if len(warriors) > len(mages) and len(warriors) > len(archers):
    style = "âš”ï¸ Brute Force â€” heavy on frontline fighters"
elif len(mages) > len(warriors):
    style = "ğŸ”¥ Arcane Dominance â€” magic-heavy party"
elif len(archers) > len(warriors):
    style = "ğŸ¹ Precision Strike â€” ranged specialists"
else:
    style = "âš–ï¸ Balanced â€” well-rounded party composition"

print(f"PARTY PROFILE: {style}")
print(f"  Warriors: {len(warriors)}  Mages: {len(mages)}  Archers: {len(archers)}")
print(f"  Healers (HealMixin): {len(healers)}")
print(f"  Total HP: {total_hp}  Avg HP: {avg_hp:.0f}")
print(f"  Classes in hierarchy: Character â†’ Warrior/Mage/Archer, Paladin(Warrior+HealMixin)")
print("=" * 55)
`;

    // â”€â”€ Wiring â”€â”€
    function save(){
      PhoneLabUI.saveDraft(WEEK, {
        studentId: studentIdEl.value, nameSurname: nameSurnameEl.value,
        email: emailEl.value, data: dataEl.value, code: codeEl.value,
        output: outEl.textContent, savedAt: new Date().toISOString()
      });
      statusEl.textContent = "Draft saved.";
    }

    function submitViaForm(payload){
      const form = document.createElement("form");
      form.method = "POST"; form.action = SCRIPT_URL; form.target = "_blank";
      const inp = document.createElement("input");
      inp.type = "hidden"; inp.name = "payload"; inp.value = JSON.stringify(payload);
      form.appendChild(inp); document.body.appendChild(form); form.submit(); form.remove();
    }

    const draft = PhoneLabUI.loadDraft(WEEK);
    if (draft){
      studentIdEl.value   = draft.studentId || "";
      nameSurnameEl.value = draft.nameSurname || "";
      emailEl.value       = draft.email || "";
      dataEl.value        = draft.data || defaultData;
      codeEl.value        = draft.code || starterCode;
      outEl.textContent   = draft.output || 'Click "â–¶ Run Python" to see output here.';
      statusEl.textContent = "Draft loaded.";
    } else {
      dataEl.value = defaultData;
      codeEl.value = starterCode;
    }

    [studentIdEl, nameSurnameEl, emailEl, dataEl, codeEl].forEach(el =>
      el.addEventListener("input", save));

    document.getElementById("runBtn").addEventListener("click", async () => {
      statusEl.textContent = "Loading Python runtimeâ€¦";
      const dataLiteral = JSON.stringify(dataEl.value);
      const codeToRun = `DATA = ${dataLiteral}\n\n` + codeEl.value;
      try {
        const out = await PhoneLabUI.runPythonCapture(codeToRun);
        outEl.textContent = out || "(no output)";
        statusEl.textContent = "âœ… Run complete.";
        save();
      } catch (e) {
        outEl.textContent = String(e);
        statusEl.textContent = "âŒ Error â€” check your code.";
        save();
      }
    });

    document.getElementById("submitBtn").addEventListener("click", () => {
      const studentId   = studentIdEl.value.trim();
      const nameSurname = nameSurnameEl.value.trim();
      const email       = emailEl.value.trim().toLowerCase();

      if (!/^\d{6,12}$/.test(studentId))
        { statusEl.textContent = "Student ID must be 6â€“12 digits."; return; }
      if (nameSurname.split(/\s+/).filter(Boolean).length < 2)
        { statusEl.textContent = "Enter Name and Surname."; return; }
      if (!/^[A-Za-z0-9._%+-]+@istun\.edu\.tr$/.test(email))
        { statusEl.textContent = "Email must be @istun.edu.tr"; return; }

      if (new Date() > DEADLINE) {
        statusEl.textContent = "â° Submission closed â€” deadline was Apr 29, 23:59.";
        return;
      }

      if (dataEl.value.replace(/\s+/g,"") === defaultData.replace(/\s+/g,"")) {
        statusEl.textContent = "âš ï¸ Enter YOUR OWN characters â€” default values are not accepted.";
        dataEl.style.outline = "2px solid #ef4444";
        setTimeout(() => dataEl.style.outline = "", 3000);
        return;
      }

      if (!outEl.textContent || outEl.textContent.includes("Click") || outEl.textContent === "(no output)")
        { statusEl.textContent = "âš ï¸ Run your code first before submitting."; return; }

      const payload = {
        week: WEEK, studentId, nameSurname, email,
        data: dataEl.value, code: codeEl.value, output: outEl.textContent,
        userAgent: navigator.userAgent, submittedAt: new Date().toISOString()
      };
      statusEl.textContent = "Submittingâ€¦";
      submitViaForm(payload);
      PhoneLabUI.setStatus(WEEK, "submitted");
    });

    const helpModal = document.getElementById("helpModal");
    document.getElementById("helpBtn").addEventListener("click", () => helpModal.style.display = "flex");
    document.getElementById("closeHelpBtn").addEventListener("click", () => helpModal.style.display = "none");
    helpModal.addEventListener("click", e => { if (e.target === helpModal) helpModal.style.display = "none"; });
    document.addEventListener("keydown", e => { if (e.key === "Escape") helpModal.style.display = "none"; });
  </script>
</body>
</html>
